# Engine Performance and Implementation Details

This document outlines the implementation details of the final reimbursement prediction engine (`reimbursement_engine.py`) and the process for generating results.

## `reimbursement_engine.py` Implementation

The `reimbursement_engine.py` module is designed to predict expense reimbursement amounts based on a k-Nearest Neighbors (k=1) model. It is implemented using only standard Python libraries (`json`, `math`) to ensure it is dependency-free.

Key components:

1.  **Initialization (`ReimbursementEngine.__init__`)**:
    *   Loads training data from `public_cases.json` upon instantiation.
    *   A fixed feature order is defined internally to ensure consistency.
    *   Calls `_load_and_prepare_training_data` to process this data.

2.  **Feature Engineering (`_engineer_features`)**:
    *   Takes a raw input case (dictionary) and generates a list of feature values in the predefined order.
    *   The features include:
        *   Raw: `trip_duration_days`, `miles_traveled`, `total_receipts_amount` (rounded to 2 decimal places upon input).
        *   Derived: `miles_per_day`, `receipt_amount_per_day`.
        *   Boolean flags: `is_5_day_trip`, `ends_in_49_cents`, `ends_in_99_cents`, `is_short_trip_low_receipts`, `is_long_trip`, `long_trip_modest_receipts_per_day`, `efficiency_sweet_spot`, `penalized_low_receipts_multi_day`.
        *   One-hot encoded `mileage_tier`: `mileage_tier_0_100`, `mileage_tier_101_500`, `mileage_tier_gt_500`.
    *   Handles `trip_duration_days = 0` for division by returning 0 for `miles_per_day` and `receipt_amount_per_day`.
    *   Cents checking for `ends_in_49_cents` and `ends_in_99_cents` is performed on the `total_receipts_amount` after it has been rounded to two decimal places.

3.  **Data Preparation (`_load_and_prepare_training_data`)**:
    *   Iterates through `public_cases.json`. For each case, it engineers features using `_engineer_features`.
    *   Calculates the mean and standard deviation for each of the (ordered) engineered features across all training cases. These statistics are stored for scaling.
    *   Scales the engineered features for all training cases using these calculated statistics via `_scale_features` and stores these scaled vectors along with the corresponding `expected_output` values.

4.  **Feature Scaling (`_scale_features`)**:
    *   Takes a list of engineered features for a case.
    *   Scales each feature using the stored means and standard deviations: `(value - mean) / std_dev`.
    *   If a feature's `std_dev` is 0 (meaning all training instances had the same value for this feature), the scaled value for that feature is set to 0.0.

5.  **k-NN (k=1) Logic**:
    *   `_euclidean_distance(vec1, vec2)`: Calculates the scaled Euclidean distance between two feature vectors.
    *   `_find_nearest_neighbor(scaled_input_features)`: Iterates through all `scaled_training_features`, calculates the Euclidean distance to the `scaled_input_features`, and returns the `expected_output` of the training case that has the minimum distance (the single nearest neighbor).

6.  **Output Nudging (`_apply_output_nudging`)**:
    *   Implements the precise nudging logic as defined in Task 4. This involves rounding the predicted value to two decimal places, then adjusting it based on its cent value to end in .00, .49, or .99 using specific rules and a fallback "closest of" mechanism.

7.  **Main Prediction (`calculate_reimbursement`)**:
    *   Orchestrates the full pipeline for a single input case (dictionary):
        1.  Engineer features.
        2.  Scale features.
        3.  Find the nearest neighbor's `expected_output` (raw prediction).
        4.  Apply output nudging to the raw prediction.
        5.  Formats the final nudged value as a string with exactly two decimal places (e.g., "123.49").

## `run.sh` Creation

*   A `run.sh` script was created to facilitate running the reimbursement engine.
*   It takes a single argument: the path to an input JSON file containing a list of travel cases.
*   The script invokes a helper Python script, `temp_runner.py`, which:
    *   Initializes the `ReimbursementEngine`.
    *   Reads the input JSON file specified by `run.sh`.
    *   For each case in the input file, it calls the engine's `calculate_reimbursement` method.
    *   Prints each resulting reimbursement amount to standard output, one per line.
*   Error handling for file existence and JSON parsing is included. `PYTHONPATH` is set to include the current directory.

## `edge_case_results.txt` Generation

*   The file `edge_case_results.txt` was generated by executing the command:
    `bash run.sh private_cases.json > edge_case_results.txt`
*   This command processes each case defined in `private_cases.json` through the `reimbursement_engine.py` and stores the sequence of predicted reimbursement amounts in `edge_case_results.txt`.

This setup ensures that the engine can be run on new data (like `private_cases.json`) using the `run.sh` script, producing the required output format.
